"""
Module which defines the car agents
"""
from mesa import Agent
import numpy as np


class Car(Agent):
    """
    Class which defines the inidividual car agents.
    Each car has a specific unique_id and an index which is the
    unique_id modulo the resolution of the LaneSpace.

    Attributes:
        unique_id (int): An integer value which is uniquely defines each agent
        model (obj): An instance of the model class
        index (int): The unique_id modulo the resolution of the LaneSpace
            defined in the model instance.
        pos (tuple): The position of the car agent. The first argument of the
            tuple defines the position along the horizontal continuous axis,
            the second value specifies the current lane of the car.
        max_speed (float): A constant value which defines the upper limit of
            the cars' speed.
        speed (float): A variable value which specifies the current speed of
            the car, cannot exceed the value defined in max_speed.
        agression (float): Defines the agression of the car, between [0,1].
            Results in the car swiching lanes more often as it increases.
            Also makes acceleration more likely if possible.
        gap (float): Defines the space cars keep between each other, relative
            to their speeds, e.g. a value of 2 would result in a gap equal to
            twice the cars' speed, so 20 meters at a speed of 10 m/s.
            Higher agression can occasionally override this specified gap.
        switch_delay (int): Defines the number of time steps a car waits
            between switching lanes. High agression lowers this value.
        switched (int): Counter for the number of time steps since last
            switching a lane. Decreases by one each timestep and allows the car
            to switch lanes if at zero. Is set to the value of switch_delay if
            the car switches a lane.
    """
    # pylint: disable=too-many-instance-attributes
    # pylint: disable=too-many-arguments

    def __init__(self, unique_id, model, start_lane,
                 speed, agression, min_gap):
        """
        Args:
            unique_id (int): The unique id of the current agent, generated by
                agent scheduler.
            model (obj): Instance of the LaneSpace model
            start_lane (int): The lane in which the car should start.
            speed (float): Initial speed of the car, also used to set the
                maximum speed of the car.
            agression (float): Agression of the car, bounded between [0,1].
            min_gap (float): The absolute minimum space the car should
                maintain, relative to it's own speed.
        """
        super().__init__(unique_id, model)
        self.start_lane = start_lane
        self.index = self.unique_id % model.grid.length
        self.pos = (0.0, start_lane)
        self.max_speed = speed+(abs(np.random.randn())*agression)
        self.speed = self.max_speed
        self.agression = agression
        self.gap = np.random.rand() / agression + min_gap
        self.switch_delay = int(5 / agression / self.model.time_step)
        self.switched = self.switch_delay

    def compute_pars(self, FRONT, BACK):
        """compute_pars

        Method which determines weather a car can switch to another lane or
        maintain it's current speed.

        Args:
            FRONT (list): A list which should contain the positions of the cars
                in front of the current car, on the right, middle and left. In
                that specific order.
            BACK (list): A list which should contain the postitions of the cars
                behind the current car, on the right, middle and left. In that
                specific order.

        Returns:
            can_left (bool): Can the car switch to the left?
            can_middle (bool): Can the car go forward?
            can_right (bool): Can the car switch to the right?
        """
        rf, mf, lf = FRONT  # right_front, middle_front, left_front
        rb, mb, lb = BACK  # right_back, middle_back, left_back

        """
        Can the car turn left?
        The available space to the left front car should be larger than the
        cars' current speed multiplied by the minimum gap the car has to
        maintain. The gap to the car behind should be 0.5 times this
        distance as the car is also moving forward.
        Also checks if a lane exists on the left and if the car has recovered
        from the previous lane switch
        """
        can_left = lf-self.pos[0] > self.gap * self.speed and\
            self.pos[0]-lb > 0.5*self.gap * self.speed and\
            self.pos[1] < (self.model.lanes - 1) and\
            self.switched == 0

        """
        Can the car turn right?
        The available space to the right front should be larger than the cars'
        current speed multiplied by the minimum gap the car has to maintain.
        The gap to the car behind should be 0.5 times this distance as the car
        is also moving forward.
        Also checks if the car is not already in the rightmost lane and has
        recovered from the previous lane switch
        """
        can_right = rf-self.pos[0] > self.gap * self.speed and\
            self.pos[0]-rb > 0.5*self.gap * self.speed and\
            self.pos[1] > 0 and\
            self.switched == 0

        """
        Can the car go forward (to the middle)?
        This gap should be larger than minimum gap multiplied by the
        cars' current speed.
        """
        can_middle = mf - self.pos[0] > self.gap*self.speed

        return can_left, can_middle, can_right

    def get_move(self):
        """
        Method which determines the best possible move of the car,
        depedent on the agression, current speed, minimal gap, and
        postions of the six surrouding cars.

        This move is determined in a loop which first determines which
        moves are initially possible. It then uses the agression of the
        car to decide if the car should keep right, overtake, maintain
        in the current lane, or slow down.

        Returns:
            Integer of the best possible move: -1 if right, 0 if forward,
            1 if left.
        """
        self.switched -= 1
        self.switched = max(0, self.switched)
        FRONT, BACK = self.model.grid.get_neighbors(self)
        rf, mf, lf = FRONT  # right_front, middle_front, left_front
        rb, mb, lb = BACK  # right_back, middle_back, left_back

        while True:
            cl, cm, cr = self.compute_pars(FRONT, BACK)  # can_left, can_middle, can_right

            if cm:  # Can i go forward at current speed?
                if cr and np.random.rand() > self.agression:
                    """
                    Keep right if possible, probability decreases with
                    increasing agression
                    """
                    self.switched = self.switch_delay
                    return -1

                if (self.speed < self.max_speed) and\
                        (np.random.rand() < self.agression):
                    """
                    Speed up if slowed down, probability increases
                    with increasing agression. Also overtake to the
                    left if possible
                    """
                    self.check_speed(FRONT[1]-self.pos[0])
                    if cl:
                        return 1
                return 0

            if cl and cr:  # Can i go left and right?
                if (self.speed < self.max_speed) and\
                        (np.random.rand() < self.agression):
                    """
                    Overtake on the left if slowed and agression allows.
                    Speed up relative to the agression of the car.
                    """
                    self.speed += np.random.rand()/self.agression*self.model.time_step
                    self.switched = self.switch_delay
                    return 1
                if np.random.rand() > self.agression:
                    """
                    Hold right if agression is low. Also slow down a bit
                    so not to overtake on the right, scaling with agression.
                    """
                    self.speed -= np.random.rand()/self.agression*self.model.time_step
                    self.switched = self.switch_delay
                    return -1
                if rf > lf:
                    """
                    Otherwise go to the lane with the most space in front.
                    """
                    return -1
                return 1

            if cl and (np.random.rand() < self.agression):  # Can i go left?
                """
                Move to the left if agression allows.
                """
                self.switched = self.switch_delay
                return 1

            if cr:  # Can i go right?
                """
                Move to the right and slow down so not to overtake on
                the right. Deceleration decreases with agresion, so
                high agression could result in an overtake on the right.
                """
                self.switched = self.switch_delay
                self.speed -= np.random.rand()/self.agression*self.model.time_step
                return -1

            """
            Slow down if none of the moves are possible and try all
            posibilites again. Recalculating the boolean values each loop.
            """
            self.speed -= np.random.rand()*self.model.time_step

    def check_speed(self, gap):
        """
        Check how much the car is slowed down and the gap to the car in front.
        Accelerate faster if agression is high, gap is large, or the car is
        slowed down a lot.

        Args:
            gap (float): Gap to the car in front
        """
        diff = self.max_speed - self.speed
        space = (gap-self.speed)/self.speed/self.gap/self.agression
        speedup = max(np.random.rand(), np.log(diff*space))*self.model.time_step
        self.speed += speedup

    def step(self):
        """
        Method used by the mesa scheduler to advance each car.
        Obtains a move from the get_move method and applies this
        to the overall LaneSpace model. Also performs a global check
        if the car is not exceeding its maximum speed.
        """
        move = self.get_move()
        self.model.move(self, move)
        if self.speed > self.max_speed:
            self.speed -= np.random.rand()*self.model.time_step
